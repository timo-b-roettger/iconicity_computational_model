---
title: "Anna's working draft for iconicity model"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::html_document2: default
  bookdown::pdf_document2: default
bibliography: latex-stuff/iconicity_lit.bib
---

```{r setup, include=FALSE}
library(knitr)

# Set knit defaults for code chunks
opts_chunk$set(
  dev = 'png', # default format of figures
  comment="",
  echo=FALSE, warning=TRUE, message=FALSE,
  cache=FALSE)

# some useful formatting functions for output of knitting
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

color_block = function(color) {
  function(x, options) sprintf('\\color{%s}\\begin{verbatim}%s\\end{verbatim}\\color{black}',
                               color, x)
}
knitr::knit_hooks$set(error = color_block('red'))
knitr::knit_hooks$set(warning = color_block('orange'))
```

```{r libraries, include=FALSE}
library(tidyverse)  # data wrangling and plotting
library(ggplot2)
```

# TO DO
* One general model for both interaction and generational overturn - what needs tweeking?
  * How does iconicity play out in production/perception c.f. learning of f-m pairs?
* Signal drift: in a model that includes acoustics, is drift equal for all cues? Is it a ratio of the category variance or merely random gaussian noise?

```{r functions, include=FALSE}
source("functions.R")
```

# Modelling iconicity
General principles to observe [@dona-schouwstra2024].
For computational models simulating the emergence of iconicity across generations, parameters of interest across generations are population size, generational overturn; for modelling individual agent behavior, learning rate and innovation tendency. Iconicity can be represented on a system-level (as a property of the system, in relation to arbitrariness, systematicity and combinatoriality), or in form-meaning pairs. The vertical transmission across generations is implemented as iterated learning.
For simulating the emergence of iconicity resulting from interactions within a population, agent based models are often used. Focus is to formalize cognitive processes and effects of population properties, size and social network structure. The horizontal transmission between agents is implemented in language games. The adaptive behavior of interlocutors supposedly takes place via some learning algorithm that can either be rule-based or sometimes modeled as a neural network.^[Models of neural networks have shown that adding an attention mechanism to the model, meant to simulate the cognitive enhancing of some parts of the input, makes the model learn faster with iconicity (syntax models).] In models of generational overturn, iconicity can be operationalized as a mapping between a set of culturally salient features and forms (formalized as sequences of n bits). The shared cultural context is represented by participants being in the same group (chain), and observations are made as to the specific patterns/features that emerges within group/chain. When interaction/identification is unsuccessful, the receiver gets one bit update on form of target concept. The mean degree of iconicity and lexical variation is calculated at each trial (between 0-1). Populations with more agents often display more lexical variability at earlier stages, but a steeper decrease in iconicity over time.

Arbitrariness assumes that form-meaning pairs are unpredictable and lack inherent connection. This is often measured by confusability index, and can be affected by interaction and feedback (more arbitrariness leads to higher complexity)---a push from communicative interaction to become more efficient can lead to increased arbitrariness. Systematicity suggests that related meanings are expressed with forms that share elements, as measures by internal consistency within participants and usuage of functional markers. Systematicity supposedly does not compete with iconicity but rather coexists. Combinatoriality, however, conflicts with iconicity in that it assumes building blocks with no meaning attached---languages consists of a limited inventory of sounds that can be combined in whatever format to represent meaning. While combinatoriality aids transmission efficiency, iconicity aids referential efficiency. 

@dona-schouwstra2024 suggest that future studies should aim to characterize the formal properties of the co-existence of iconicity with systematicity and combinatoriality.

## Experiment data
* Lexical learning in an interaction game between Agent A and Agent B.
* Prior to game play, both agents are trained on the form-meaning pairs up to a certain threshold.
* Interaction round:
  * agent A and agent B takes turns alternating roles of listener and speaker
  * speaker gets a random referent (picture and consonant context) and produces a signal
  * listener selects the perceived referent from a grid of 4 options
  * each form-meaning pair is presented 3 times for each agent in each condition (speaking, listening)?
  * on each trial, listeners receive feedback on their guess (negative or positive)---to do, add feedback to speaker as well

## Model specification
Formalized parameters of the model.

### Lexical representation
A combination of two vectors: one with category information, one with cue information---c(F1,F2) in the simplest case (could be expanded to include formant trajectories, duration, f0).

### Categorization/recognition/learning
Learning involves uncertainty---imperfect learning. Can be formalized as the input being pertubated by noise and participants lapsing. Here, noise is added to trials where interaction fails, formalized as signal drift.
Uncertainty during learning is structured---lexical competition by attractors (already existing vowel categories in Norwegian). Open question how much weight attached to each attractor, and whether all existing categories are possible (cued by consonant context?). How are these attractors defined---what cue values are assigned to the prototypes?
There is motor noise, neural noise, environmental noise for both production and perception of target representations. Production/perception noise is likely unstructured and slightly off the represented values of L (like gaussian noise).
Ideally, noise, lapse and iconicity should be fit to the data when running the model?

Learning of form-meaning pairs is formalized as guessing rate. Strength of guess rate is a function of previous learning/listener memory (priors), the characteristics of the signal and the referent type. Added to this is iconicity as learnability bias; e.g., if smaller referents are closer to their spatial prototype, their are easier to guess, and vice versa.

At each round, guessing rate/probability of listener and speaker is updated based on learning. If internal guess strength > .5 (=correct), speaker retrieves signal for referent and the signal remains the same. If the guess < .5 (=incorrect), there is no recall and the draws a new signal near c(.5,.5) with noise. This is formalized as the signal drifting randomly. In either case, the guessing probability increases at each round, more so on correct than incorrect trials, but there is always learning.

### Iconicity
The emergence of iconicity is formalized as a learnability bias that favors signals that are more closely located to their target in a 2-dimensional space; some form-meaning pairs are thus easier to learn/guess depending on their spatial proximity to iconic prototypes. Prototypes are either small or large as defined in a contained space (yet not acoustic).

It is conceivable that learnability bias is not enough for iconicity to emerge. Possible additional mechanisms include:
  * signal update: currently, the only dynamic shaping force on the signal is random Gaussian noise when communication fails. This means that there is no directional pressure pushing small signals to move towards [0,0] or large signals to move towards [1,1], hence, no push of signals towards the iconic target (no directional evolution). This is also true for speakers: when the speaker is confident, the signal is copied exactly, meaning there is no refinement; when the speaker is unsure, the signal drifts. So there is no production bias towards more iconic signals.
  * learning update: the guess probabilities improve over time while signal drift decreases, meaning that the signal tends to freeze near its initial state [.5,.5].
  * the iconicity function = ease function which improves listeners' probability of correct guesses, but it does not affect the likelihood of the speaker producing good-guess signals.
  
Possible changes:
  * add a production bias toward iconic prototypes, e.g., when selecting a signal, sample with mean shifted toward [0,0] or [1,1] --> affects signal generation
  * make failed signals adjust toward the prototype, not random drift --> affects signal correction on failure (more subtle source of bias)
  * add cultural selection bias where successful signals get reinforced --> affects memory update

```{r}
# show heatmap of ease relative to signal space
grid <- expand.grid(
  x = seq(0, 1, length.out = 50),
  y = seq(0, 1, length.out = 50),
  type = c("small", "large"))

# make heat map
grid <- grid %>%
  rowwise() %>%
  mutate(ease = signal_ease(c(x, y), type)) %>%
  ungroup()

ggplot(grid,
       aes(x = x, y = y, fill = ease)) +
  geom_tile() +
  facet_wrap(. ~type) +
  scale_fill_viridis_c()

```

## Model implementation
### Iconicity bias
Some signals are easier to learn/guess depending on their spatial proximity to iconic prototypes.
Prototype small = c(0,0), large = c(1,1); as defined in a contained space.

### Distance-based signal ease
Small referents closer to their prototype, [0,0], are easier to guess, and large referents are easier to guess near [1,1]. Distance drop off sharply (exponentially) when moving away from targets. Signal ease is an attractor that expresses distance to iconicity target/prototype, multiplied with iconicity boost to adjust for larger influence of iconicity. The distance metric is Euclidean distance <!--Consider other distances?-->

### Probability of correct guess
p(correct guess) = previous guessing rate + signal fit (incl. iconicity bias) --> learned ability (priors) + iconicity boost * signal ease. The added learning boost of ease is reduced by a factor 'iconicity_boost' which represents the strength of iconicity affecting guessing. This is a constant that can be changed by the researcher to account for the strength of iconicity.
Bounded at .95 to account for .05 noise/lapse. Implemented as drawing from a random beta distribution.
The initial learning state of the learner (after training) is summarized to an averaged probability of ~.33. These are established by drawing n random values from a beta distribution with a mu=.333 and sigma=.032.

### Learning
Learning rate = .005. This is added to the listener guess at each round. If guess is correct (as sampled from a binomial distribution), the same rate is added to the listener guess again.

### Signal drift
If communication fails, signal drifts randomly by adding 2D Gaussian noise. This is sampled from a distribution with mu=0, sigma=.05 (atm), and bounded to [0,1]. This simulates the amount of variation in production (currently, undirectional, meaning that it shifts the signal randomly in the space but stays relatively close to the original signal [.5,.5]; one might reasonably suppose that the signal might instead drift in some predefined direction).
the signal drifts but is it repeated to the listener? Meaning, it will continuously be worse as a signal? <!--Don't get this entirely?-->

```{r parameters}
# Generate empty dataframe for simulation
d.empty <- data.frame(
  sim      = integer(),
  round    = integer(),
  referent = integer(),
  speaker  = character(),
  listener = character(),
  type     = character(),
  p_correct = numeric(),
  success   = integer(),
  stored_x  = numeric(),
  stored_y  = numeric(),
  produced_x = numeric(),
  produced_y = numeric(),
  stringsAsFactors = FALSE)

d.history <- d.empty %>%
  run_interaction_sim(n_sim = 10, n_rounds = 1000)
```

```{r iconicity}
# you can compute iconicity either from stored signals or produced tokens
d.iconicity <- d.history %>%
  mutate(bins = cut(round, breaks = 20, labels = FALSE)) %>%
  group_by(bins, type, sim) %>%
  summarise(
    x_learned = mean(stored_x),
    y_learned = mean(stored_y),
    x_produced = mean(produced_x),
    y_produced = mean(produced_y),
    .groups = "drop") %>%
  pivot_longer(
    cols = starts_with(c("x", "y")),
    names_to = c("signal", "process"),
    values_to = "value",
    names_sep = "_") %>%
  pivot_wider(
    names_from = signal,
    values_from = value) %>%
  mutate(
    target_x = ifelse(type == "small", 0, 1),
    target_y = ifelse(type == "small", 0, 1),
    dist = sqrt((x - target_x)^2 + (y - target_y)^2),
    iconicity = exp(-2 * dist)) %>%
  group_by(bins, sim, process) %>%
    summarise(iconicity = mean(iconicity), .groups = "drop")
```

```{r iconicity-plot}
#iconicity trajectories (produced tokens and stored signals)
p1 <- d.iconicity %>%
  filter(process == "learned") %>%
  group_by(bins, sim) %>% 
  summarise(iconicity = mean(iconicity)) %>%
  ggplot(
    aes(x = bins, y = iconicity, group = sim)) +
  geom_path(size = 0.9, alpha = 0.2) +
  geom_path(data = iconicity_agg_produced, aes(group = 1), size = 1.5) +
  geom_hline(yintercept = exp(-2 * sqrt((0.5)^2 + (0.5)^2)), lty = "dashed") +
  scale_y_continuous(limits = c(0,1), breaks = seq(0,1,0.25)) +
  labs(title = "Iconicity over time (produced tokens)",
       y = "Iconicity (high = iconic)", x = "Bins (rounds in 100s)") +
  theme_minimal()

p2 <- d.iconicity %>%
  filter(process == "produced") %>%
  group_by(bins, sim) %>% 
  summarise(iconicity = mean(iconicity)) %>%
  ggplot(
    aes(x = bins, y = iconicity, group = sim)) +
  geom_path(size = 0.9, alpha = 0.2) +
  geom_path(data = iconicity_agg_stored, aes(group = 1), size = 1.5) +
  geom_hline(yintercept = exp(-2 * sqrt((0.5)^2 + (0.5)^2)), lty = "dashed") +
  scale_y_continuous(limits = c(0,1), breaks = seq(0,1,0.25)) +
  labs(title = "Iconicity over time (stored signals)",
       y = "Iconicity (high = iconic)", x = "Bins (rounds in 100s)") +
  theme_minimal()

print(p1)
print(p2)

```

## Check the effect of different parameter settings

```{r}
param_grid <- expand.grid(
  prod_bias = seq(0, 0.3, length.out = 4),
  iconicity_boost = seq(0, 0.4, length.out = 4),
  reinforcement_rate = c(0.02, 0.05, 0.1),
  learn_rate = c(0.002, 0.005, 0.01))

grid_results <- data.frame()

compute_iconicity <- function(history, n_rounds) {
  
  hist_agg <- history |> 
    dplyr::mutate(bins = cut(round, breaks = 20, labels = FALSE)) |> 
    dplyr::group_by(bins, type, sim) |> 
    dplyr::summarise(
      signal_x = mean(stored_x),
      signal_y = mean(stored_y),
      .groups = "drop"
    )

  iconicity <- hist_agg |> 
    dplyr::mutate(
      target_x = ifelse(type == "small", 0, 1),
      target_y = ifelse(type == "small", 0, 1),
      dist = sqrt((signal_x - target_x)^2 + (signal_y - target_y)^2),
      iconicity = exp(-2 * dist)
    ) |> 
    dplyr::group_by(bins, sim) |> 
    dplyr::summarise(iconicity = mean(iconicity), .groups = "drop")

  # return average iconicity in final 20% of bins
  final_bins <- max(iconicity$bins) * 0.8
  mean(iconicity$iconicity[iconicity$bins >= final_bins])
}

for (i in 1:nrow(param_grid)) {
  
  # extract params
  params <- param_grid[i, ]

  # prepare empty df for the simulation
  empty_df <- data.frame(
    sim = integer(), round = integer(), referent = integer(),
    speaker = character(), listener = character(), type = character(),
    p_correct = numeric(), success = integer(),
    stored_x = numeric(), stored_y = numeric(),
    produced_x = numeric(), produced_y = numeric(),
    stringsAsFactors = FALSE
  )

  # run the model
  hist <- run_interaction_sim(
    data = empty_df,
    n_sim = 5,            # small number for medium-fast grid search
    n_referents = 6,
    n_rounds = 800,       # enough time for iconicity to emerge
    drift_sd = 0.05,
    learn_rate = params$learn_rate,
    iconicity_boost = params$iconicity_boost,
    prod_bias = params$prod_bias,
    reinforcement_rate = params$reinforcement_rate,
    lapse = 0.05
  )

  # compute iconicity
  mean_iconicity <- compute_iconicity(hist, n_rounds = 800)

  # store results
  grid_results <- rbind(
    grid_results,
    data.frame(
      prod_bias = params$prod_bias,
      iconicity_boost = params$iconicity_boost,
      reinforcement_rate = params$reinforcement_rate,
      learn_rate = params$learn_rate,
      iconicity = mean_iconicity
    )
  )

  print(paste("Completed parameter set", i, "of", nrow(param_grid)))
}

```

```{r}
ggplot(grid_results,
       aes(x = prod_bias,
           y = iconicity_boost,
           fill = iconicity)) +
  geom_tile() +
  scale_fill_viridis_c() +
  theme_minimal() +
  labs(
    title = "Iconicity Emergence Across Parameter Grid",
    x = "Production Bias (toward prototype)",
    y = "Interpretation Bias (iconicity_boost)",
    fill = "Final Iconicity"
  )

ggplot(grid_results,
       aes(x = prod_bias, y = iconicity_boost, fill = iconicity)) +
  geom_tile() +
  scale_fill_viridis_c() +
  facet_grid(reinforcement_rate ~ learn_rate) +
  theme_minimal() +
  labs(
    title = "Iconicity Emergence: Full Parameter Grid",
    x = "Production Bias",
    y = "Interpretation Bias",
    fill = "Iconicity"
  )


```




